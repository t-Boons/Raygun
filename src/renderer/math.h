#pragma once
#include "light.h"


// https://gist.github.com/volkansalma/2972237 
#define PI_FLOAT     3.14159265f
#define PIBY2_FLOAT  1.5707963f
// |error| < 0.005
inline float fastatan2(float y, float x)
{
	if (x == 0.0f)
	{
		if (y > 0.0f) return PIBY2_FLOAT;
		if (y == 0.0f) return 0.0f;
		return -PIBY2_FLOAT;
	}
	float atan;
	float z = y / x;
	if (fabs(z) < 1.0f)
	{
		atan = z / (1.0f + 0.28f * z * z);
		if (x < 0.0f)
		{
			if (y < 0.0f) return atan - PI_FLOAT;
			return atan + PI_FLOAT;
		}
	}
	else
	{
		atan = PIBY2_FLOAT - z / (z * z + 0.28f);
		if (y < 0.0f) return atan - PI_FLOAT;
	}
	return atan;
}

// https://stackoverflow.com/questions/3380628/fast-arc-cos-algorithm 
// Modified to have less digit precision.
inline float fastacos(float x) {
	return (-0.69f * x * x - 0.87f) * x + 1.57f;
}


inline float copySign(float num)
{
	return (num < 0) * 2.0f - 1.0f;
}

// Code taken from: https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel.html
inline float3 refract(const float3& uv, const float3& n, float etai_over_etat)
{
	float cos_theta = fmin(dot(-uv, n), 1.0f);
	float3 r_out_perp = etai_over_etat * (uv + cos_theta * n);
	float3 r_out_parallel = -sqrt(fabs(1.0f - sqrLength(r_out_perp))) * n;
	return r_out_perp + r_out_parallel;
}

inline float3 samplePointOnAreaLight(const AreaLight& light, Random& rand)
{
	const float3 right = float3(0, 0, 1);
	const float3 up = float3(1, 0, 0);

	// Hard coded to always point from up to down for now.
	const float3 point = light.position +
		right * ((rand.Float() - 0.5f) * light.width) +
		up * ((rand.Float() - 0.5f) * light.height);

	return point;
}

// Code taken from:  https://raytracing.github.io/books/RayTracingInOneWeekend.html
inline float fresnelSchlick(float cosine, float ref_idx) {
	// Use Schlick's approximation for reflectance.
	float r0 = (1 - ref_idx) / (1 + ref_idx);
	r0 = r0 * r0;
	return r0 + (1 - r0) * powf((1.0f - cosine), 5);
}

inline float3 attenuation(const float3& watts, float distance)
{
	return watts * 1.0f /  (distance * distance);
}

inline float3 bilinearInterp(const float* texture, float u, float v, int width, int height, int channels)
{
	const float x = u * (float)width;
	const float y = v * (float)height;

	// Calculate the difference form the pixel to the sample.
	const float udiff = x - floorf(x);
	const float vdiff = y - floorf(y);
	const float undiff = 1.0f - udiff;
	const float vndiff = 1.0f - vdiff;

	int indexTL = ((int)y * width) + (int)x;
	int indexTR = indexTL + 1;
	int indexBL = (((int)y + 1) * width) + (int)x;
	int indexBR = indexBL + 1;

	// Ensure indices are within bounds
	indexTL = max(0, min(indexTL, width * height - 1));
	indexTR = max(0, min(indexTR, width * height - 1));
	indexBL = max(0, min(indexBL, width * height - 1));
	indexBR = max(0, min(indexBR, width * height - 1));

	float3 sum = float3(texture[indexTL * channels], texture[indexTL * channels + 1], texture[indexTL * channels + 2]) * undiff * vndiff +
		float3(texture[indexTR * channels], texture[indexTR * channels + 1], texture[indexTR * channels + 2]) * udiff * vndiff +
		float3(texture[indexBL * channels], texture[indexBL * channels + 1], texture[indexBL * channels + 2]) * undiff * vdiff +
		float3(texture[indexBR * channels], texture[indexBR * channels + 1], texture[indexBR * channels + 2]) * udiff * vdiff;

	return sum;
}

inline float3 sampleFrom4Pixels(float* texture, int x, int y, int width, int height, int channels)
{
	int indexTL = (y * width) + x;
	int indexTR = indexTL + 1;
	int indexBL = ((y + 1) * width) + x;
	int indexBR = indexBL + 1;

	// Ensure indices are within bounds
	indexTL = max(0, min(indexTL, width * height - 1));
	indexTR = max(0, min(indexTR, width * height - 1));
	indexBL = max(0, min(indexBL, width * height - 1));
	indexBR = max(0, min(indexBR, width * height - 1));

	float3 sum = float3(texture[indexTL * channels], texture[indexTL * channels + 1], texture[indexTL * channels + 2]) +
		float3(texture[indexTR * channels], texture[indexTR * channels + 1], texture[indexTR * channels + 2]) +
		float3(texture[indexBL * channels], texture[indexBL * channels + 1], texture[indexBL * channels + 2]) +
		float3(texture[indexBR * channels], texture[indexBR * channels + 1], texture[indexBR * channels + 2]);

	return sum * 0.25;
}


// Generated by: ChatGPT
inline uint32_t morton3D(uint32_t x, uint32_t y, uint32_t z)
{
    uint32_t morton = 0;
    for (uint32_t i = 0; i < sizeof(uint32_t) * 8; ++i)
    {
        morton |= (x & 1U << i) << 2 * i | (y & 1U << i) << (2 * i + 1) | (z & 1U << i) << (2 * i + 2);
    }
    return morton;
}


// Taken and modified to cpp from: https://www.shadertoy.com/view/Wt3fzB#
// tc ∈ [-1,1]² | fov ∈ [0, π) | d ∈ [0,1]
inline float3 paniniProjection(float2 tc, float fov, float d)
{
	const float d2 = d * d;

	{
		const float fo = PI05 - fov * 0.5f;

		const float f = cosf(fo) / sinf(fo) * 2.0f;
		const float f2 = f * f;

		const float b = (sqrtf(max(0.0f, powf(d + d2, 2) * (f2 + f2 * f2))) - (d * f + f)) / (d2 + d2 * f2 - 1.0f);

		tc *= b;
	}

	/* http://tksharpless.net/vedutismo/Pannini/panini.pdf */
	const float h = tc.x;
	const float v = tc.y;

	const float h2 = h * h;

	const float k = h2 / powf(d + 1.0f, 2);
	const float k2 = k * k;

	const float discr = max(0.0f, k2 * d2 - (k + 1.0f) * (k * d2 - 1.0f));

	const float cosPhi = (-k * d + sqrtf(discr)) / (k + 1.0f);
	const float S = (d + 1.0f) / (d + cosPhi);
	const float tanTheta = v / S;

	float sinPhi = sqrtf(max(0.0f, 1.0f - powf(cosPhi, 2)));
	if (tc.x < 0.0f) sinPhi *= -1.0f;

	const float s = rsqrtf(1.0f + powf(tanTheta, 2));

	return float3(sinPhi, tanTheta, cosPhi) * s;
}

// Generated by Chatgpt and modified.
inline uint32_t calculateMipmapLevel(int textureSize, float screenSpaceFootprint)
{
	// Calculate the Mipmap level based on the ratio of texture footprint to screen space footprint
	float ratio = textureSize / screenSpaceFootprint;
	int level = 0;
	while (ratio > 2 && textureSize > 1)
	{
		textureSize /= 2;
		ratio /= 2;
		++level;
	}

	return level;
}

// https://developer.download.nvidia.com/assets/gameworks/downloads/secure/main.pdf?BBmPa8Fw11N0svpb92sYbrPRnuIiYQiCmHT6YX8IC62oISFEUod83WMNkb58Qpl5YD78FqTCZzwoBmMVC0O0QfIkNPUR7bsTHoxyVDa77k7uNpiU-JMjl078DwriKdNfKAWSRCSNdo9j&t=eyJscyI6ImdzZW8iLCJsc2QiOiJodHRwczovL3d3dy5nb29nbGUuY29tLyJ9
inline float3 differencial(int x, int y, float s_x, float s_y, float3 r, float3 u, float3 v)
{
	const float3 cx = ((float)(2 * x + 1) / s_x - 1);
	const float3 cy = ((float)(2 * y + 1) / s_y - 1);

	return (cx * r + cy * u + v);
}


inline bool contains(const float3& bl, const float3& tl, const float3& pos)
{
	// test if pos is inside the cube // AABB type calculation.
	return pos.x >= bl.x && pos.y >= bl.y && pos.z >= bl.z &&
		pos.x <= tl.x && pos.y <= tl.y && pos.z <= tl.z;
}

// min3 is used in normal reconstruction.
inline float3 min3(const float3& a, const float3& b)
{
	return float3(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));
}

// Returns t (distance from intersection) // Created by Jacco Bikker
class Ray;
float intersects(const float3& bl, const float3& tr, const Ray& ray);


enum class PrimitiveType : uint8_t
{
	None, 
	Voxel,
	Sphere,
};

float2 getUV(const float3& I, const float3& N, PrimitiveType type);
	
inline mat4 createMatrix(const float3& position, const float3& rotation, const float3& scale)
{
	return	mat4::Identity() *
		mat4::Translate(position) *
		mat4::RotateX(rotation.x) * mat4::RotateY(rotation.y) * mat4::RotateZ(rotation.z) *
		mat4::Scale(scale + 0.00005f);
}

// taken from https://stackoverflow.com/questions/12774207/fastest-way-to-check-if-a-file-exists-using-standard-c-c11-14-17-c
inline bool fileExists(const std::string& name)
{
	if (FILE* file = fopen(name.c_str(), "r")) {
		fclose(file);
		return true;
	}
	else {
		return false;
	}
}

float3 getNormal(const float3& I, const float3& DSign, PrimitiveType type);

// Code snippet created by Robin (Peer) than modified to be const-correct and allow for fov.
inline float2 worldSpaceToScreenSpace(const float3& point, const float3& camPos, const float3& forward, float aspect, float fov)
{
	static const float nearPoint = 2.0f;

	float3 to_point = point - camPos;
	const float3 to_point_nrm = normalize(to_point);

	const float3 view_right = normalize(cross(float3(0.0, 1.0, 0.0), forward));
	const float3 view_up = cross(forward, view_right);

	float d = max(dot(forward, to_point_nrm), 0.0f);
	if (d < 0.01f) return float2(0.0f, 0.0f);

	d = nearPoint / d;

	to_point = to_point_nrm * d - forward * nearPoint;
	to_point *= tanf(fov * 0.017453f) * 0.5f;

	// sets point between [-1, 1]
	const float x = dot(to_point, view_right);
	const float y = dot(to_point, view_up);
	float2 uv = float2(x, y);
	uv.x /= aspect;
	// sets point to [0, 1]
	uv = uv * 0.5f + 0.5f;
	uv.y = 1 - uv.y;
	return uv;
}

inline float3 randomPointOnHemisphere(const float3& normal, Random& rand)
{
	float3 randDir = normalize({ rand.Float() - 0.5f, rand.Float() - 0.5f, rand.Float() - 0.5f });
	return dot(normal, randDir) > 0.0f ? randDir : -randDir;
}

inline float3 randomFloat3(float min, float max, Random& rand)
{
	return float3(rand.Float() * (max - min) + min,
				  rand.Float() * (max - min) + min,
				  rand.Float() * (max - min) + min);
}

template<int N, int S>
static constexpr std::array<float, N> getGridCellSizes()
{
	std::array<float, N> out;
	int gridSize = S;
	for (size_t i = 0; i < N; i++)
	{
		out[i] = 1.0f / gridSize;
		gridSize /= 2;
	}
	return out;
}

template<int N, int S>
static constexpr std::array<int, N> getGridSizes()
{
	std::array<int, N> out;
	int gridSize = S;
	for (size_t i = 0; i < N; i++)
	{
		out[i] = gridSize;
		gridSize /= 2;
	}
	return out;
}

template<int N, int S>
static constexpr std::array<int, N> getGridSizes2()
{
	std::array<int, N> out;
	int gridSize = S;
	for (size_t i = 0; i < N; i++)
	{
		out[i] = gridSize * gridSize;
		gridSize /= 2;
	}
	return out;
}

template<int N, int S>
static constexpr std::array<int, N> getGridBufferIndices()
{
	std::array<int, N> out;
	uint32_t bufferStart = 0;
	uint32_t gridSize = S;
	for (size_t i = 0; i < N; i++)
	{
		out[i] = bufferStart;
		bufferStart += gridSize * gridSize * gridSize;
		gridSize /= 2;
	}

	return out;
}

inline float3 abs3(const float3& f)
{
	return { abs(f.x), abs(f.y), abs(f.z) };
}

// Created by chatgpt.
inline float gaussianWeight(float intensity_diff, float sigma_color) {
	return exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));
}

// Created by chatgpt.
// Calculate the Gaussian weight for spatial distance
inline float spatialWeight(float spatial_diff, float sigma_space) {
	return exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));
}

inline void bilateralFilter(float3* buffer, const float3* comparer, const int width, const int height, const int radius)
{
	for (int i = 0; i < width; i++)
	{
		for (int j = 0; j < height; j++)
		{

			float3 sum{ 0 };
			float3 weightSum{ 0 };

			for (int k = -radius; k <= radius; ++k)
			{
				for (int l = -radius; l <= radius; ++l)
				{
					const int ni = i + k;
					const int nj = j + l;

					if (ni >= 0 && ni < height && nj >= 0 && nj < width)
					{
						const float3 diff = abs3(comparer[ni + nj * width] - comparer[i + j * width]);

						const float kf = (float)k; const float lf = (float)l;
						const float spatDiff = spatialWeight(sqrtf(kf * kf + lf * lf), 2.0f);

						const float3 weight = float3{ gaussianWeight(diff.x, 2.0f),
							gaussianWeight(diff.y, 2.0f),
							gaussianWeight(diff.z, 2.0f) } * spatDiff;

						sum += buffer[ni + nj * width] * weight;
						weightSum += weight;
					}
				}
			}

			buffer[i + j * width] = sum / weightSum;
		}
	}
}